## 数据结构

### 物理结构

所有数据结构的物理表示都只有3种：

1. 数组
2. 链表
3. 数组加链表的组合

### 逻辑结构

#### 线性数据结构：数据的存储顺序是连续的

* 队列：
  * 普通队列：用两个指针表示队列首尾（head,tail）,head指向队列中目前最先加入的节点，tail指向队列中目前最后加入的节点或该节点的后一个下标，
    * 数组表示：随着入队出队，head指针前的空间将浪费，tail一直指向尾结点的后一个下标，此种方式几乎不使用
    * 链表表示：修改head与tail的指向即可，注意tail 指向链表中最后一个节点，这是队列的常用使用方式。
  * 循环队列：
    * 数组表示：通过取模而不是直接在下标添加节点实现，添加节点`（tail++)%array.length`,删除节点`(head++)%array.length`,
      队列已满`(tail+1)%array.length==head`,此种方法将浪费一个节点
    * 链表表示：使用原始链表即可
  * 双端队列(deque)：队列与栈的组合,可以从任意首尾入队或出队，类似redis的list结构
  * 优先级队列：本质上已经不是队列，它不是普通队列线性的数据结构，是使用完全二叉树（二叉堆）利用数组实现的一种数据结构，堆顶是最小或最大的元素，每次出队相当于删除堆顶的元素，入队相当于在数组末添加一个新元素再重新调整堆结构
* 栈：先进后出，可以保存元素加入的先后关系，用于回溯或递归比较多，多用数组实现，拥有一个栈顶指针指向最后一个加入的元素



#### 非线性数据结构：数据的存储顺序是连续的

* 树：
  * 二叉树：每个节点拥有两个子节点指针
    * 链表实现：略
    * 数组实现：左子节点等于`parent*2+1`，右子节点等于`parent*2+2`，父节点等于`(child-1)/2`,这种实现方式浪费空间，普通的树不使用这种方式
  * 满二叉树：所有叶子节点到根节点的距离相等，除叶子节点外所有节点都有两个节点。
  * 完全二叉树：与满二叉树十分相似，只是叶子节点这一层不要求排满，但叶子节点要遵守从左到右的排列顺序，中间不能有空缺。
  * 排序二叉树：又称二叉查找树，除叶子结点外，所有节点的左子节点值要小于该节点，右子节点值要大于该节点。
  * 平衡二叉树：任何一个节点的左右子树的高度（从该节点到到最深的子节点的长度，子节点为空则为零）差不超过一。
  * 平衡二叉查找树：又称AVL树，在平衡二叉树的基础上遵循二叉查找树的要求。
  * 红黑树：是标准的二叉查找树，红黑树属于不严格意义下的平衡二叉树。说它不严格是因为它不是严格控制左、右子树高度或节点数之差小于等于1。但正因为不用严格遵守这条规则，它旋转的次数必AVL树少,添加和插入的效率更高，但查询效率有所降低。但总体效率还是更高，应该优先选用红黑树
  * 二叉堆：使用数组实现的完全二叉树，并且每个节点总是大于/小于它的孩子节点（注意与二叉查找树的区别）
  * 2-3树：每个节点拥有两个值，三个孩子节点的指针，设这两个值为（a<b）,则三个指针分别值指向小于a的子节点，值在a与b之间的节点，大于b的节点，红黑树可以理解为一种特殊的2-3树。
  * B树：对2-3查找树的一种扩展，即他==允许==除根节点外（根节点必须有两个子节点），每个节点有M-1个子节点（M指树的深度）。每个节点有M个值（是==允许==，不是必须要），且这些值在同一层各个节点中从左到右主键递增。
  * B+树：**B+**树是对B树的一种变形树，除根节点（根节点必须有两个子节点）和叶子结点外，它要求每个节点==必须==有M-1个子节点（M指树的深度），但非叶子节点==没有值，只有指针==（如：他有指向小于等于或大于存有10这个值的节点的指针，但它自己没有一个变量存储10这个值），并且叶子节组成==有序链表==（可以单向，也可以双向），所有的查找最终==都要到叶子结点获取值==，而B树可以在中间节点获取值。
  * 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；