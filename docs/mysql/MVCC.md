> MySQL InnoDB MVCC实现 https://zhuanlan.zhihu.com/p/40208895
>
> MySQL InnoDB MVCC 机制的原理及实现https://zhuanlan.zhihu.com/p/64576887

## 什么是MVCC？

mvcc  (Multiversion Concurrency Control)翻译过来就是多版本并发控制的意思，它在解决数据库的事务并发处理上除了上锁外，提供了另一种解决方案，并且目前流行的数据库都采用了这种方式。

多版本：当事务内对某条记录执行insert,update,delete等操作时，Mysql保存执行前的数据在undo log日志中，并且根据不同的事务id保存多个不同的版本，每个版本之间通过指针连接成链表

并发控制：控制数据库在事务并发的处理方式。

**使用MVCC**

优点：多个事务只有添加undo log时才会短暂上锁，极大提高性能。

缺点：只能运行在特定的隔离级别，且不能解决幻读与丢失更新的问题。

**使用锁**

优点：完美解决脏读、不可重复读、幻读、丢失更新这四个问题

缺点：多个事务只有RR才不上锁，RW,WR,WW都会上锁，且必须等待事务提交，否则一致等待，十分影响性能



## InnoDB MVCC实现原理

**DATA_TRX_ID**

记录最近更新这条行记录的`事务 ID`，大小为 `6` 个字节

**DATA_ROLL_PTR**

表示指向该行回滚段`（rollback segment）`的指针，大小为 `7` 个字节，`InnoDB` 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在 `undo` 中都通过链表的形式组织。

**DB_ROW_ID**

行标识（隐藏单调自增 `ID`），大小为 `6` 字节，==如果表没有主键==，`InnoDB` 会自动生成一个隐藏主键，因此会出现这个列。另外，每条记录的头信息（`record header`）里都有一个专门的 `bit`（`deleted_flag`）来表示当前记录是否已经被删除

## 如何组织版本链

事务 `A` 对值 `x` 进行更新之后，该行即产生一个新版本和旧版本。假设之前插入该行的事务 `ID` 为 `100`，事务 `A` 的 `ID` 为 `200`，该行的隐藏主键为 `1`

| field1 | field2 | DB_ROW_ID | DATA_TRX_ID | DATA_ROLL_PTR    |
| ------ | ------ | --------- | ----------- | ---------------- |
|        |        | 1         | 100         | 指向前一条记录   |
|        |        | 1         | 200         | 新插入的记录为空 |

事务 `A` 的操作过程为：

1. 对 `DB_ROW_ID = 1` 的这行记录加排他锁（复制这条记录时所有其他事务都不能读写这条记录）
2. 把该行原本的值拷贝到 `undo log` 中，`DB_TRX_ID` 和 `DB_ROLL_PTR` 都不动
3. 修改该行的值这时产生一个新版本，更新 `DATA_TRX_ID` 为修改记录的事务 `ID`，将 `DATA_ROLL_PTR` 指向刚刚拷贝到 `undo log` 链中的旧版本记录，这样就能通过 `DB_ROLL_PTR` 找到这条记录的历史版本。如果对同一行记录执行连续的 `UPDATE`，`Undo Log` 会组成一个链表，遍历这个链表可以看到这条记录的变迁
4. 记录 `redo log`，包括 `undo log` 中的修改

那么 `INSERT` 和 `DELETE` 会怎么做呢？其实相比 `UPDATE` 这二者很简单，`INSERT` 会产生一条新纪录，它的 `DATA_TRX_ID` 为当前插入记录的事务 `ID`；`DELETE` 某条记录时可看成是一种特殊的 `UPDATE`（同样复制一条记录只是所有字段为空），其实是软删，真正执行删除操作会在 `commit` 时，`DATA_TRX_ID` 则记录下删除该记录的事务 `ID`。

## 如何实现一致性读-ReadView

在 `RU` 隔离级别下，直接读取版本的最新记录就 OK，对于 `SERIALIZABLE` 隔离级别，则是通过加锁互斥来访问数据，因此不需要 `MVCC` 的帮助。因此 `MVCC` 运行在 `RC` 和 `RR`这两个隔离级别下，当 `InnoDB` 隔离级别设置为二者其一时，在 `SELECT` 数据时就会用到版本链（其他如 update/insert/delete还是需要通过加锁来解决）

首先明确：事务ID（transaction id）并不是 执行`begin`就会生成，必须等到执行第一条DML语句时才行（任意增删改查），且新申请的事务ID只会在当前最大的事务ID上增加

### ReadView结构

1. up_limit_id表示该SQL启动时，当前事务链表中未提交的最小的事务id编号，也就是当前系统中创建最早但还未提交的事务【表示未提交的事务中的最小的一个，比他还小的事务ID一定是已经提交的，不然up_trx_id将会是哪个更小的事务ID】；
2. low_limit_id表示该SQL启动时，当前事务链表中最大的事务id编号，也就是最近创建的除自身以外最大事务编号；
3. trx_ids表示所有事务链表中未提交事务的id集合。

==注意==：**up_limit_id**和**low_limit_id**与当前活跃事务id列表的最大最小值无关，并且不是针对某一条记录，而是整个数据库所有表，事务是针对数据库这个整体而言的。即在同一个事务中修改两张表，两张表中的记录会是同一个`DATA_TRX_ID`

###  RC(Read commited)下ReadView的生成

在读已提交的情况下，每一次执行`select`语句，都会生成一个新的ReadView，它会重新计算	`up_limit_id`，`low_limit_id`，`trx_ids`。然后根据当前`undo log`链表中的第一条记录的`DATA_TRX_ID`判断返回那一条记录

* 如果当前记录的DATA_TRX_ID小于up_limit_id，那么这条记录一定是已经提交过的，直接在链表中返回当前记录即可
* 如果当前记录的DATA_TRX_ID大于low_limit_id，表示当前记录事务ID大于生成ReadView时的最大事务ID，innodb将无视这条记录，链表向后移动，重新执行判断。【注意，这种情况一般只有RR时才会出现，因为RC每一次都会重新构建ReadView,low_limit_id获取的一定是当前最大的事务ID,很难出现DATA_TRX_ID大于low_limit_id的情况】
* 如果DATA_TRX_ID位于两者之间，则继续判断是否在trx_ids中，==在==则表示该事务尚未提交，本次访问对其应该是不可见的，所以跳过该条记录，判断链表的下一条记录。如果==不在==，表示该事务已经提交，返回当前记录

### RR(Repeatable Read)下ReadView的生成

在可重复读的情况下，事务第一次执行`select`语句，会生成一个ReadView，之后的每一次`select`,都将使用该ReadView进行判断，也就是说它只关注当前已经提交的事务，不管其他事务开启的时间是在它之前还是它之后，只要当前事务开启时没提交，那么在他们的事务中所有对特定记录的更改对当前事务都不可见【由up_limit_id,low_limit_id,trx_ids创建后就不改变保证】，保证了可重复读下的数据一致性。但它也只是保证对事务开启时已经存在的记录的更改的不可见，如果其他事务新增了记录并且当前事务执行的是范围查询，任然会导致数据的不一致，这就是`幻读`。并且由于保证每次读取数据的一致性，其他事务对数据的更新因为不可见将导致丢失，这就是`更新丢失`，解决幻读与更新丢失必须提升隔离级别到`SERIALIZABLE`,此时每一个事务都是串行执行，MVCC失去作用。