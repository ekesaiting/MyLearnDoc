## 内部类分类

假设外部类类名为`OuterClass`,内部类类名`InnerClass`

### 常规内部类

* 访问修饰符：可以是public ,默认，==private==
* 常规内部类不能有静态字段，也不能有静态方法，编译器报错。
* 内部类拥有一个实例变量,变量类型为`OuterClass`，变量名为`this$0`,值为`OuterClass`的一个对象引用地址，
* 内部类的默认构造函数不同于普通类的默认构造函数，它拥有一个默认参数，对应外部类的一个对象，在构造函数的内部将这个值赋值给`this$0`,通常是外部类对象的`this`指针变量,由此可知：
  * 每一个常规内部类对象的创建==必须==先创建一个外部类对象
  * 内部类的方法并不能访问`this$0`这个变量，它是编译器添加的，我们写代码的时候不存在，但可以认为`OuterClass.this`=`this$0`，访问外部类字段可以省略`OuterClass.this`，直接使用外部类对象的字段。
* 可以将内部类访问修饰符声明为private,它表明只有在外部类里才可以创建内部类对象，在外部不能直接使用这个内部类，相当于这个内部类的作用域被限定在这个类里，而你不能使用import导入这个类，所有与这个内部类或内部类对象相关的行为与属性都必须通过外部类或外部内对象访问，他现在已经彻底属于这个类了，而不是这个包
* 外部类并没有任何字段指向内部类对象，无论是对外部类还是其他类，他都是平等的，就好像是一个普通的类，只是
  * 它的类名被修改为`OuterClass.InnerClass`，而不是`InnerClass`，java不能以`.`为类名，所以在虚拟机内部表示为`OuterClass$InnetClass`，在外部类内部可以省略`OuterClass`,但其他类不行。
  * 它的默认构造函数接受一个值为外部类对象的参数
* 为什么内部类可以访问外部类的私有变量？，编译器给外部类添加了静态方法`access$0`,他接受一个外部类对象作为参数，返回访问的外部内私有变量，如：当内部类访问外部类的私有变量`name`时，等于调用`OuterClass.access$0(this$0)`，当访问多个外部内私有变量时，会生成多个这种方法，比如`access$00`,`access$000`，每一个对应一个私有字段
* 内部类声明的所有`static`字段都必须同时声明`final` ，意思就是内部类只有常量字段与实例字段。

**总结**：可以将常规内部类等价为外部类的一个实例方法/字段使用，在不创建外部类对象的情况下是内部类对象不可能存在或者创建。也不可能在外部类外直接使用new的方式直接创建内部类，（因此所有直接创建的内部类都是静态内部类），只能通过先创建一个外部类对象，再通过外部类对象的方法得到一个内部类对象（如果方法存在的话）

### 局部内部类

* 局部内部类通常写在外部类的方法里，而不是直接定义在外部类内部，它的作用域被限制在声明这个局部类的块中。所以局部内部类并不是一定要写在方法里，在外部类代码块中写的也是局部内部类
* 局部内部类拥有所有等同于被`private`修饰的常规内部类的用法，但除此外，它还可以访问局部变量，但这些变量必须是事实最终变量，即被`final`修饰，或者这个变量的之不可变，如`String`类型的变量，
* 那为什么可以访问方法的形参？他不是可变的吗？当创建内部类时，如果他访问了局部变量，那么编译器将在内部类内部添加一个`final`修饰的在原有变量名前添加`val$`的字段，并且在内部类的默认构造方法中将再添加一个或多个参数（取决于访问局部变量的个数），并且在构造方法内给这些`val$`字段初始化。实现局部变量的复制，当局部变量消失时，创建的内部类对象仍然持有局部变量的值。

### 匿名内部类

* 匿名内部类可以认为是一种特殊的局部内部类，可以认为是以下方式的简写

  ```java
  
  {
      class Tmp implements Runable{
      public void run(){
          sout("hello");
      	}
  	}
      var run=new Tmp();
  }
  
  
  //以下两种方式等同于上面的简写，省略了实现类的类名，局部代码块就是（）
  var run=new Runable(){
  	public void run(){
  	sout("hello");
  	}
  }
  new Thread(new Runable(){
      sout("hello");
  })
  ```

* 匿名内部类没有名字，也就不能手动添加构造方法，只能由编译器添加默认构造方法，并在默认构造方法内将参数传递给父类的构造方法，如果是实现的接口，那不能有任何构造参数，因为接口没有构造函数，他默认继承Object类，而Object类的构造函数是一个无参构造。

* 匿名内部类可以有对象初始化代码块

### 静态内部类

静态内部类与常规内部类的两个最大区别

* 静态内部类对象没有外部类对象的引用
* 静态内部类可以有静态字段与方法。

接口中声明的内部类都是静态内部类

**总结**：静态内部类可以等价为一个外部类的static方法/字段，与外部类中其他static方法使用无异。静态字段的初始化与对象无关，因此静态内部类对象的创建与外部类对象无关，它除了可以直接使用外部类的静态字段与方法（必须要加类名外）和创建对象时需要加外部类的名字外,与正常的类没有任何区别。