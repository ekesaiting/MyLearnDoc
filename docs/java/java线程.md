## Thread的常用方法

Thread 中的sleep 与yield等方法与锁完全无关，它们只是属于Thread的静态方法，只能操作当前线程的状态，而锁是由其他对象控制的，这些静态方法与此完全无关，

因此，

* sleep相当于让线程进入time_wiated状态，它进入这个状态时的锁的状态它完全不关心，原状态是什么就是什么状态，不会改变
* yield相当于该给操作系统的线程调度器发出一个信号，表示愿意让出当前时间片，操作系统可以选择不理会，之后该线程进入就绪状态，与其他线程共同等待分配时间片
* wait属于object的实例方法，只有对象能够调用，也就是锁对象能够调用，他表示当前线程愿意放弃锁的拥有权，并加入到属于该对象的waited队列中，等待其他线程中执行该锁对象的notify或notifyAll方法唤醒该线程进入就绪队列
* 当线程处于waited或timed_waited时，其他线程可以调用该线程的interupt方法，给该线程发送一个中断信号，操作系统会立即唤醒该线程，当该线程获得时间片时，并且竞争到锁（如果有锁的话，没竞争到锁又会陷入该锁对象的等待队列中）会立即抛出一个中断异常，线程必须捕获该异常(因为是受检异常)，然后执行catch中的代码逻辑，其他非受检异常不处理的话线程将退出,异常将交给默认的未捕获异常处理器处理。
* wait()方法调用线程是进入对象锁的阻塞队列，如果其他线程没有调用notify()方法，这个线程永远不能再次执行。sleep调用后线程是进入jvm的等待队列，等待时间到后重新进入CPU的等待队列重新分配cpu时间
* wait()使线程进入WATIED状态，sleep()使线程进入TIME_WAITED状态

## 为什么wait()/notify()一定要在同步方法中调用？

被synchrponized修饰的方法表示同一时间只有一个方法能够调用，wait()方法当前线程表示释放锁并且阻塞当前线程,如果线程都没有获得锁对象，那他显然不能释放别的线程已经拿到的锁，所以会抛出异常，如果没有同步代码块修饰，任何线程都可以随时调用notify()方法唤醒阻塞的线程，显然已经不满足同步的要求

## 阻塞

阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。 直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状 态。阻塞的情况分三种：

* **等待阻塞**：运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue) 中。
* **同步阻塞**：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线 程放入锁池(lock pool)中。
* **其他阻塞**：运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时， JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行(runnable)状态。

## 其他

* 线程执行完后只是表示run方法执行完，线程对象还是保存在堆中。

## 线程池

> 线程池的实现原理https://blog.csdn.net/anhenzhufeng/article/details/88870374

* 当线程池中的线程数量小于核心数量时，线程池新建一个Worker对象（创建worker对象会通过线程工厂新建一个线程与当前worker绑定）将它放入HashSet<Worker> workers 中，同时将这个任务直接交个这个新创建的线程执行
* 如果线程池的线程数量大于核心数量时，将这个任务放入创建线程时提供的阻塞队列中，workers中的线程会不断死循环从workerQueue中获取提交最久的任务，如果workerQueue为空，workers中的线程会阻塞，如果此时线程数大于核心线程数，这个worker对象会销毁，它持有的线程对象也会销毁，线程资源释放。
* Worker实现了Runable接口，但它的run方法是一个死循环，里面执行的是真正提交的Runable任务，只有满足一定条件时才会退出死循环，销毁当前线程

## 概念

* 非阻塞：就是一个死循环，当前栈帧一致在栈顶，受cpu时间片分配管理。
* 异步：就是回调，当前方法调用后栈帧立即退栈，当满足条件后jvm会通知对应线程调用注册的回调方法，若果提前获取结果，还是会造成阻塞。
* 阻塞：当前栈帧无法返回退出，操作系统根据具体情况将其加入阻塞队列还是等待队列。

### 3.5.1 线程状态及状态转换

当多个线程同时请求某个对象监视器时，对象监视器会设置几种状态用来区分请求的线程：

Contention List：所有请求锁的线程将被首先放置到该竞争队列

Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List

Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set

OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck

Owner：获得锁的线程称为Owner

!Owner：释放锁的线程

