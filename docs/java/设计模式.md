> 设计模式 https://www.yuque.com/docs/share/f89b9dd3-3b3b-4ef9-b1cb-9d9d0f3ba109?#94KW7

## 设计模式七大基本原则

### 1.单一职责原则 (Single Responsibility Principle)

一个类应该只负责一种的功能.如Annimal有一个move方法，但发现有些动物表现出来的行为有些不同，如普通动物是跑，鸟是飞，鱼是游，解决办法：

* 将Annimal拆分创建多个子类在分别实现对应的方法
* 但更好的解决办法是将move这个行为与annimal这个对象分离，创建一个Move的接口，再创建Fly,Run等实现类

通过组合的方式使Annimal这个类描述动物的属性，而Move描述动物移动的属性，维持单一职责。

### 2.开放-封闭原则 (Open-Closed Principle)

增加新的功能时可以拓展（继承，实现）达到要求，但不能直接修改源码

### 3.里氏替换原则 (Liskov Substitution Principle)

子类可以扩展父类的功能，但不能改变父类原有的功能。

当使用继承时候，类 B 继承类 A 时，除添加新的方法完成新增功能 P2，尽量不要修改父类方法预期的行为。

比如需要在子类中增强父类的方法时，尽量不直接重写父类的方法，而是额外提供一个方法，保证通过父类的引用调用该方法时与该方法在父类中的描述一致

### 4.依赖倒转原则 (Dependence Inversion Principle)

高层模块不应该依赖低层模块，二者都应该于抽象。进一步说，抽象不应该依赖于细节，细节应该依赖于抽象。

**依赖倒转原则的核心思想就是面向接口编程**，

### 5.接口隔离原则 (Interface Segregation Principle)

1. 接口隔离原则的思想在于建立单一接口，**尽可能地去细化接口，接口中的方法尽可能少**
2. 但是凡事都要有个度，如果接口设计过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。

### 6.迪米特法则（Law Of Demeter）

迪米特法则又称为 最少知道原则，它表示一个对象应该对其它对象保持最少的了解。通俗来说就是，只与直接的调用的对象通信。不管对象内部又需要进行多长的对象调用，本对象的方法应该只影响它直接调用对象的状态，而被调用对象内部又调用的其他对象的状态改变应该由被调用对象自己负责

### 7.组合/聚合复用原则 (Composite/Aggregate Reuse Principle)

组合/聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分; 新的对象通过向这些对象的委派达到复用已有功能的目的

总结：能用组合就别用继承

## 创建型设计模式

### 简单工厂模式

因为只需要一个工厂类，所以称为简单工厂，通过不同的参数传递给该工厂的方法就可以得到不同的对象，不关注工厂内部是使用什么方法创建的对象，可以是简单的if else或者switch case根据参数的不同直接创建不同的对象，也可以如spring将对象保存在map中根据id从map中获取beanInfinition再从中返回bean对象

### 工厂方法模式

通过一个工厂接口定义了一个通用的获取对象的方法，然后由多个工厂接口的实现类分别生产不同的对象

### 抽象工厂模式

因为工厂方法只能生产一种类型的对象（只有一个获取对象的方法），而抽象工厂模式在工厂方法模式的基础上，增加了多个获取别的类型对象的方法，

### 单例模式

**所有单例的前提都需要构造函数私有化**

#### 饿汉式单例

伴随类的加载而创建

#### 懒汉式单例

双重检测锁，静态内部类，枚举

### 原型模式

使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。

在java中需要考虑的就是深拷贝与浅拷贝

### 建造者模式

创建复杂对象才需要，它将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。通过不同的builder可以创建不同的对象，将创建对象的复杂流程在builder中，这些builder可能内部使用了一些相同的方法或都需要构建相同的组件，通过提供封装程度不同的builder可以减少用户创建对象时的复杂度（也可以提供空白的builder由用户自定义构建流程）

## 结构型设计模式

### 装饰模式

不改变原有对象的前提下，动态地给一个对象增加一些额外的功能。

### 门面模式

提供一个顶级的类或接口暴露给用户，将子系统的逻辑封装在该类内部，减少用户调用的麻烦，但违反了开闭原则，父类向下引用了具体的实现，添加新的子类实现时需要修改父类源码

### 代理模式

#### 静态代理

编译前就存在代理类

#### 动态代理

运行时动态生成代理类

### 享元模式

共用组件。如在父类或接口中定义一个static静态变量给所有子类或实现类共用

### 桥接模式

将抽象部分与它的实现部分分离,使它们都可以独立地变化。参考单一职责的举例

### 适配器模式

将一个接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式的别名是包装器模式

* Target（目标抽象类）：目标抽象类定义客户所需接口，被客户直接访问，可以是一个抽象类或接口，也可以是具体类

* Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过实现Target接口并继承/关联一个Adaptee对象使二者产生联系

* Adaptee（适配者类）：适配者类作为被适配的角色，它定义了一个已经存在的功能接口(旧方法)，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码

#### 类适配器模式

适配器与适配者之间是**继承**(或实现)关系

#### 对象适配器模式

适配器与适配者之间是**关联**关系

## 行为型设计模式