> Java 中new String("字面量") 中 "字面量" 是何时进入字符串常量池的?https://www.zhihu.com/question/55994121

## Try

* try代码块中返回try代码块外的局部变量时会先复制一份值/引用地址保存在局部变量表中的另一个位置，然后执行finally中的代码，finally中操作的是初始的值/局部变量所在的局部变量表的索引位置，执行完fiinally后才执行返回复制的值/地址的指令。
* try块相当于定义一块局部代码块，他有自己的作用域，其内部定义的局部变量外部不可访问。

## Synchronized

* 当synchronized修饰方法时，是一种隐式的同步机制，表现在方法的修饰符中的synchronized标志位置为1，其字节码指令与没有sync修饰的没有任何区别，没有monitorenter和monitorexit。如果该标志位为1，线程执行该方法时，会先判断当前线程是否已经获得该对象的同步锁，没有的话当前线程将加入该对象的阻塞队列。
* 当synchronized修饰代码段是，是一种显示的同步机制，表现在字节码指令中有monotorenter和monitorexit两条指令，执行monitorexnter会判断当前对象的同步监视器计数器（与该java对象相对应的一个c++对象中的属性）为0才会进入，如果为1，再判断当前线程是否持有当前方法所属对象的锁，持有然后同步监视器计数器+1,不是的话当前线程加入该对象的阻塞队列。方法执行完的话就是将同步监视器计数器值-1，（具体实现jdk不同版本有所不同）

## String

就HotSpot VM的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在StringTable中并没有相应的引用，在堆中也没有对应的对象产生），也就是说只有在赋值时（执行ldc指令时）才会在jvm堆中创建代表String类型的对象，并且创建前会判断全局的字符串常量池（相当于hashSet<String>）是否已经包含了该对象（两个相同字符序列的hashcode值相等）如果未包含，则创建新对象并将其加入字符创常量池并将新对象的地址赋值给变量,如果包含则直接将字符串常量池中的引用地址赋值给变量。

总结：

* 每个类加载后都有自己的运行时常量池（在方法区中），里面存储的与是静态的class文件中的常量池结构类似的c++对象（如 utf8_info在运行时常量池中存储的就是一个执行Symbol类型的指针，Symbol类型的成员与class文件中的结构类型（length of byte array,length of string,string等属性），其他各种表如：method_info都有对应的c++对象，他们在内存中以c++对象的形式完整反映了class文件常量池的内容与结构）
* 所有的class一旦被加载入jvm后将共享一个字符串常量池，即在java堆中，不管多少个class文件中有”java“这个字面量，也不管多少个线程中有多少个String被赋值”java“，代表”java“的String对象在不利用new String()等方式创建的情况下，**都只会有一个**
* `private static String s="java"`，并不是说给s这个变量赋值一个“java”这个符号,作为引用类型变量，他只能接受长度为四个字节的地址值，实质为jvm执行 ldc这个指令时，会通过字符串常量池最终获得代表“java”的一个String类型对象的地址值，如果为`final`修饰，则在链接阶段的解析阶段获得对象地址值，如果只有`static`修饰，则在类初始化时（<clint>）获得对象地址值

## 准备/初始化

被`fianl`修饰的就是常量，并不需要`static`修饰，搭配`static`只是可以避免创建对象与所有对象共享。

准备阶段会给被`final`修饰的基本数据类型赋予初值，也必须赋予初值，因为`fianl`修饰的变量只能赋予一次值，如果此时不赋值的话，那么所有的被`fianl`修饰的基本数据类型都是默认值`0`等，以后初始化时也无法改变。被`final`修饰的String类型会在准备时创建String对象，其他被`final`修饰的引用类型，即使是常量，也都是在类初始化（<clint>）时才赋予初值，也就是说准备阶段他们没有默认值，可以认为跳过了准备阶段的默认初始化（常量即使是被赋予`null`,也被认为值就是null,不能再次修改）

总结：

* 只有通过字面量形式赋值的常量（`Integer.Max_Value`,`"String s=a"+"b"`等形式也等同于字面量，即必须在编译时确定值）才会在准备阶段赋予初值，其他通过调用方法，new（）等其他方式获得初值的方式都是在<clinit>中赋值，都会跳过准备阶段的默认初始化，准备阶段只是分配内存空间